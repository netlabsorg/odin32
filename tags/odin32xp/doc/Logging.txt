/* $Id: Logging.txt,v 1.3 2004-12-20 18:11:09 sao2l02 Exp $ */

            	Odin Logging and Profiling
            	~~~~~~~~~~~~~~~~~~~~~~~~~~

1.0 Standard logging feature
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The alpha 5 binaries and daily build zipfiles can generate logfiles to show 
what a win32 application is doing. This can be very useful to determine
why certain applications don't run correctly.

The major disadvantage of loggging is the overhead. Therefor it has been 
disabled by default in the alpha 5 release and daily builds.
To enable logging set the environment variable WIN32LOG_ENABLED:
   SET WIN32LOG_ENABLED=1

To disable logging again, you must clear this variable:
   SET WIN32LOG_ENABLED=


2.0 Extended logging features (new as of February 16th)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Disabling or enabling logging for all the Odin dlls isn't always useful.
To make logging more flexible, you can now disable or enable separate
source files for each dll (NOTE: Only implemented in kernel32, user32 & gdi32
for now)

Each dll that supports this feature has a file called dbglocal.cpp in it's
source directory. It contains a listing of all the sources files for that dll
(DbgFileNames) and an array with boolean values for each of those files.
To add this feature to a dll, you must do the following:
	- Write a custom dbglocal.cpp & dbglocal.h.
	- Every source file must include dbglocal.h with the correct debug constant:
		#define DBG_LOCALLOG	DBG_directory
		#include "dbglocal.h"
	- Initterm.cpp must call ParseLogStatus when the dll is loaded

Each dprintf now first checks if logging is enabled for this sourefile before
calling WriteLog. (NOTE: dbglocal must be included *after* misc.h)

When building a debug version of a dll, logging is enabled for all source files
by default.

2.1 Examples of custom logging
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Disable logging for kernel32, but enable it for profile.cpp & wprocess.cpp
	set dbg_kernel32=-dll +profile +wprocess


Enable logging for kernel32, but disable it for profile.cpp & wprocess.cpp
	set dbg_kernel32=+dll -profile -wprocess
This works currently for this dlls.
gdi32 with this source file names
"gdi32",
"opengl",
"callback",
"dibsect",
"initterm",
"resource",
"oslibgdi",
"font",
"text",
"palette",
"line",
"oslibgpi",
"region",
"metafile",
"dibitmap",
"blit",
"rgbcvt",
"objhandle",
"transform",
"printer",
"icm",
"trace",
"fontres",
"devcontext"
kernel32 with this source file names
"kernel32",
"kobjects",
"console",
"conin",
"conbuffer",
"conout",
"network",
"hmdevio",
"profile",
"thread",
"virtual",
"thunk",
"obsolete",
"comm",
"message",
"resource",
"exceptions",
"heapshared",
"cpuhlp",
"heapcode",
"lfile",
"npipe",
"oslibdos",
"oslibmisc",
"misc",
"exceptutil",
"lang",
"iccio",
"map",
"win32util",
"heap",
"heapstring",
"os2heap",
"vmutex",
"initterm",
"handlemanager",
"environ",
"initsystem",
"hmdevice",
"hmopen32",
"hmobjects",
"hmevent",
"hmmutex",
"hmcomm",
"hmsemaphore",
"wprocess",
"conprop",
"conprop2",
"winimagelx",
"winimagebase",
"windllbase",
"winexebase",
"time",
"mmap",
"winimagepe2lx",
"winimagepeldr",
"windllpe2lx",
"windlllx",
"windllpeldr",
"winexepe2lx",
"winexelx",
"winexepeldr",
"winres",
"critsection",
"pefile",
"winimgres",
"wintls",
"async",
"fileio",
"hmtoken",
"kernelrsrc",
"atom",
"disk",
"directory",
"cvtbitmap",
"hmmmap",
"cvtaccel",
"cvticon",
"cvticongrp",
"oslibexcept",
"cpu",
"process",
"cvtcursor",
"cvtcursorgrp",
"stubs",
"interlock",
"toolhelp",
"codepage",
"debug",
"oslibdebug",
"registry",
"queue",
"hmthread",
"hmprocess",
"vsemaphore",
"exceptstackdump",
"hmfile",
"hmnpipe",
"hmdisk",
"version",
"hmstd",
"module",
"mailslot",
"hmmailslot",
"hmparport",
"hmnul",
"overlappedio",
"trace",
"event",
"mutex",
"semaphore",
"nls",
"memory",
"system",
"string",
"char",
"osliblvm",
"oslibtime",
"conodin32",
"oslibmem",
"mmapview",
"mmapdup",
"oslibthread",
"mmapnotify"
user32 with this source file names
"user32",
"loadres",
"dde",
"win32wndhandle",
"wsprintf",
"winmouse",
"icon",
"hook",
"winkeyboard",
"defwndproc",
"syscolor",
"char",
"initterm",
"uitools",
"unknown",
"spy",
"wndmsg",
"display",
"pmwindow",
"pmframe",
"win32class",
"win32wnd",
"win32dlg",
"msgbox",
"window",
"windowmsg",
"windowclass",
"win32wbase",
"windowword",
"gen_object",
"oslibwin",
"win32wndchild",
"controls",
"button",
"static",
"scroll",
"listbox",
"menu",
"combo",
"edit",
"winswitch",
"icontitle",
"clipboard",
"winicon",
"win32wmdiclient",
"oslibutil",
"oslibmsg",
"dib",
"oslibdos",
"win32wmdichild",
"wingdi",
"oslibgdi",
"winaccel",
"win32wbasepos",
"oslibres",
"dc",
"timer",
"caret",
"resource",
"winproc",
"text",
"oslibmsgtranslate",
"windlgmsg",
"windlg",
"win32wdesktop",
"win32wbasenonclient",
"win32wbaseprop",
"dcrgn",
"message",
"trace",
"property",
"rect",
"paint",
"dragdrop",
"oslibclip",
"oslibkbd",
"win32wfake"
controls with this source file names
"controls",
"button",
"static",
"scroll",
"listbox",
"menu",
"combo",
"edit",
"winswitch",
"icontitle",
"initterm",
"trace",
"dialog"
uxtheme with this source file names
"uxtheme"
vdmdbg with this source file names
"vdmdbg"
version with this source file names
"info",
"install",
"resource"
winmm with this source file names
"os2timer",
"waveout",
"waveoutdart",
"time",
"wavein",
"auxiliary",
"auxos2",
"mixer",
"midi",
"irtmidi",
"midistrm",
"initterm",
"mci",
"joy",
"mmio",
"driver",
"playsound",
"joyos2",
"resource",
"waveindart",
"waveoutdaud",
"waveoutbase",
"waveinoutbase"
ws2_32 with this source file names
"initterm",
"ws2_32"
wsock32 with this source file names
"initterm",
"wsastruct",
"wsock32",
"unknown",
"async",
"asyncthread",
"wsa"

3.0 ODIN Profiler
~~~~~~~~~~~~~~~~~

If the ODIN executables are compiled with IBM VisualAge C++ 3.08 and
the generation of profile hooks is enabled (/Gh+), the runtime library
ODINCRTP will reroute the _ProfileHook32 calls to the ODINPROF library.
This is done by some sophisticated stack trickery.
ODINPROF will be called upon each entry and exit of compiled C functions and
C++ member functions. The profiler will then try to load the symbolic debug
information file according to the module name (i. e. KERNEL32.sym) and
lookup the symbol name according to the function's entry address. C++ name
demangling is done automatically.
If this fails, the profiler will auto-generate symbolic names.
If a symbol table could be loaded, but the address looked for could not be
found exactly in the debug information, the profiler will revert to the 
closest symbol found and add the address difference as an offset suffix.
(i. e. _MyAPI@4+1234h)

Upon process termination the profiler will yield a file named '<pid>.prof'.
It will contain a number of sorted tables about the collected performance 
data.


