<HTML>
<HEAD>
<TITLE>OpenC++ Reference Manual</TITLE>
</HEAD>
<BODY>

<H1>Representation of Environments</H1>

<P>
 <CODE><B>Environment</B></CODE> metaobjects represent bindings between names and
types.
If the name denotes a variable, it is bound to the type of that variable.
Otherwise, if the name denotes a type, it is bound to the type itself.
Programmers can look up names by the following
member functions on <CODE><B>Environment</B></CODE> metaobjects:</P>

<HR>

<H2><IMG SRC="red-pin.gif"> Public Members</H2>

<UL><CODE><NOBR>
<IMG SRC="green.gif" ALT=" o "><A HREF="#mem5">Dump</A>()<BR>
<IMG SRC="green.gif" ALT=" o "><A HREF="#mem6">Dump</A>(int i)<BR>
<IMG SRC="green.gif" ALT=" o "><A HREF="#mem0">Lookup</A>(Ptree* name, bool& is_type_name, TypeInfo& t)<BR>
<IMG SRC="green.gif" ALT=" o "><A HREF="#mem1">Lookup</A>(Ptree* name, TypeInfo& t)<BR>
<IMG SRC="green.gif" ALT=" o "><A HREF="#mem2">LookupClassMetaobject</A>(Ptree* class_name)<BR>
<IMG SRC="green.gif" ALT=" o "><A HREF="#mem4">RecordPointerVariable</A>(char* name, Class* metaobject)<BR>
<IMG SRC="green.gif" ALT=" o "><A HREF="#mem3">RecordVariable</A>(char* name, Class* metaobject)<BR>
</NOBR></CODE></UL>
<HR>
<UL>
<A NAME="mem0">
</A><PRE><IMG SRC="green.gif" ALT=" o "><B>bool Lookup(Ptree* name, bool& is_type_name, TypeInfo& t)</B></PRE>
<P>
This looks up the given <CODE><B>name</B></CODE> into the environment and
returns <CODE><B>true</B></CODE> if found.  The type of <CODE><B>name</B></CODE> is returned at <CODE><B>t</B></CODE>.
If the name is a type name, <CODE><B>is_type_name</B></CODE> is set to <CODE><B>true</B></CODE>.  If it is a variable name, <CODE><B>is_type_name</B></CODE> is set to <CODE><B>false</B></CODE>.</P>
<A NAME="mem1">
</A><PRE><IMG SRC="green.gif" ALT=" o "><B>bool Lookup(Ptree* name, TypeInfo& t)</B></PRE>
<P>
This is an alias of <CODE><B>Lookup(Ptree*, bool&, TypeInfo&)</B></CODE> described above.</P>
<A NAME="mem2">
</A><PRE><IMG SRC="green.gif" ALT=" o "><B>Class* LookupClassMetaobject(Ptree* class_name)</B></PRE>
<P>
This looks up the given <CODE><B>class_name</B></CODE> and returns the <CODE><B>Class</B></CODE> metaobject of the type.
If the <CODE><B>class_name</B></CODE> is not found, this function returns <CODE><B>nil</B></CODE> (<CODE><B>class_name</B></CODE> may be a variable name.)</P>
<A NAME="mem3">
</A><PRE><IMG SRC="green.gif" ALT=" o "><B>bool RecordVariable(char* name, Class* metaobject)</B></PRE>
<P>
This records a variable <CODE><B>name</B></CODE> in the environment.
The type of that variable is a class type specified
by <CODE><B>metaobject</B></CODE>.</P>
<A NAME="mem4">
</A><PRE><IMG SRC="green.gif" ALT=" o "><B>bool RecordPointerVariable(char* name, Class* metaobject)</B></PRE>
<P>
This records a variable <CODE><B>name</B></CODE> in the environment.
The type of that variable is a pointer type to the class specified
by <CODE><B>metaobject</B></CODE>.</P>
<A NAME="mem5">
</A><PRE><IMG SRC="green.gif" ALT=" o "><B>void Dump()</B></PRE>
<P>
This is for debugging and prints the elements in the inner-most
environment on stderr.</P>
<A NAME="mem6">
</A><PRE><IMG SRC="green.gif" ALT=" o "><B>void Dump(int i)</B></PRE>
<P>
This is for debugging and prints the elements
in the <CODE><B>i</B></CODE>-th outer environment on stderr. <CODE><B>Dump(0)</B></CODE> is equivalent to <CODE><B>Dump()</B></CODE>.</P>
</UL>
<HR>
[<A HREF="index.html">First</A> | <A HREF="ptree.html">Prev</A> | <A HREF="typeinfo.html">Next</A>]
</BODY>
</HTML>
